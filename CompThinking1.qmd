---
title: "ComputationalThinking1"
author: "Ward, A., Miller, P."
format: 
  pdf: default
editor: visual
---

# Activity 7: Computational thinking 1: functions and iteration

Download Packages

```{r}
library(tidyverse)
library(here)
```

# 1. Functions

## Working with single values as input

```{r}
# Create a new function called add_one
# x will be the only input to the function
add_one  <- function(x){
  
  # Add x and 1 together, store as the object "output"
  output <- x + 1
  
  # Print out whatever is stored in "output"
  return(output)
  
} 
```

Using our function

```{r}
# Supply 10 to our function
add_one(x = 10)
```

More complicated function

```{r}
# Create a new function called add_together
# x and y will be the two arguments to the function
add_together  <- function(x, y){
  
  # Add x and y together, store as the object "output"
  output <- x + y
  
  # Print out whatever is stored in "output"
  return(output)
  
} 
```

### Q1.1 Feed our new function two numbers

```{r}
add_together(x=3, y=5)
```

### Q1.2 Feed our new function a number and a character string

```{r eval=FALSE}
add_together(3, "five")
```

"Error in x + y : non-numeric argument to binary operator"

Access source code of function

```{r}
add_together
```

### Q1.3 Create your own function!

```{r}
#Create Math_time
math_time <- function(x,y,z){
  output <- (x-y)^2 / z
  return(output)
}

#Run Math_time
math_time(5,2,9)
```

Output = 1

## Working with vectors as input

```{r}
# Create a function called lbs_to_kg that takes a data object 'weights' as input
lbs_to_kg  <- function(weights){
  
  # Multiply weights by 0.454, store as the object "output"
  output <- weights*0.454
  
  # Print out whatever is stored in "output"
  return(output)
  
} 
```

```{r}
#Create the vector
bison <- c(1000, 800, 1200, 1400)
```

```{r}
#Feed it into the function
lbs_to_kg(weights = bison)
```

### Q1.4 Calculate deviation from a mean

```{r}
#Creating deviation function
deviation <- function(my_vector) {
  mean <- mean(my_vector) 
  output <- mean - my_vector
  return(output)
}
```

```{r}
#Bison SD
deviation(my_vector = bison)
```

# 2. Iteration

```{r}
# Look at the first 6 rows of iris
head(iris)
```

### Q2.1: What are the units that the sepal and petal columns are measured in?

```{r}
?iris
#All measurements in centimenters
```

```{r}
#Can do this for each column 
iris %>% 
  group_by(Species) %>% 
  summarize(Sepal.Length = mean(Sepal.Length),
            Sepal.Width = mean(Sepal.Width),
            Petal.Length = mean(Petal.Length),
            Petal.Width = mean(Petal.Width))
```

Instead we can use across!

```{r}
#Using Across
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width), 
                   .fns = mean))
```

```{r}
#Using coloumn from length to pedal width
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = Sepal.Length:Petal.Width, 
                   .fns = mean))
```

```{r}
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = 1:4, 
                   .fns = mean))
```

Using everything()

```{r}
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = everything(), 
                   .fns = mean))
```

### Q2.2 Summarize to calculate the median across all columns

```{r}
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = Sepal.Length:Petal.Width, 
                   .fns = median))
#Changed .fns to median
```

```{r}
#where() to select columns
iris %>%
  group_by(Species) %>% 
  summarize(across(.cols = where(is.numeric), 
                   .fns = mean))
```

### Q2.3 Summarize to calculate the mean across all numeric columns in the cereal data

```{r}
#read in cereal df
cereal <- read_csv("./data/cereal.csv")
```

```{r}
#Mean across all numeric columns
cereal %>%
  group_by(mfr) %>% 
  summarize(across(.cols = where(is.numeric), 
                   .fns = mean))
```

## For-loops

### Loop through a simple equation

```{r}
#most basic loop
for (i in 1:5) {
  # Print out whatever the value of i is
  print(i)
}
```

Multiply i value by 2

```{r}
for (i in 1:5) {
  print(i*2)
}
```

### Q2.4 Create a for loop that iterates from 1 to 10 and squares the value of the index `i`

```{r}
for (i in 1:10) {
  print (i^2)
}
```

### Simulate data using a for-loop

```{r}
N0 = 100  #initial population size

years = 20  #number of years into the future

N = vector(length = years)  # create an empty vector to store pop. sizes

N[1] = N0  #initial population size should be the first N

lambda = 1.2  #growth rate
```

```{r}
#Printing the full vector
print(N)
```

```{r}

#Look at one element in vector
N[5]
```

```{r}
# For every year t in 2 through 20 (remember, "years" also equals 20), apply the following equation
for (t in 2:20) {
  N[t] = N[t - 1] * lambda # Apply the equation
}
```

Check N

```{r}
N
```

```{r}
# Store the data output as a dataframe for plotting
popn_data <- tibble(years = 1:years, # Make the years column = 1, 2, 3, ..., 20
                    popn = N) # Make the population column the corresponding population vector that we calculated
```

Plot the data

```{r}
# Now plot the data with years on the x axis and population on the y
popn_data %>% 
  ggplot(aes(x = years, y = popn)) +
  geom_point()
```

### Q2.5a Rerun the for loop with the following parameters:

```{r}
#Changing intial parameters
N0 = 300  #initial population size

years = 50  #number of years into the future

N = vector(length = years)  # create an empty vector to store pop. sizes

N[1] = N0  #initial population size should be the first N

lambda = 0.95  #growth rate
```

```{r}
#Rerun loop for 50
for (t in 2:50) {
  N[t] = N[t - 1] * lambda # Apply the equation
}

#Look at N now
N
```

```{r}
# Store the data output as a dataframe for plotting
popn_data2 <- tibble(years = 1:years, # Make the years column = 1, 2, 3, ..., 50
                    popn = N) # Make the population column the corresponding population vector that we calculated
```

### Q2.5b Plot the data and interpret

```{r}
popn_data2 %>% 
  ggplot(aes(x = years, y = popn)) +
  geom_point()
```

Changing the initial population size and the population growth rate causes a exponential decline to the overall population size.

### Loop through data frames

```{r}
head(iris)
```

```{r}
#Extract row 1
iris[1,]

#Extract column 3
iris[,3]

#Extract exact cell
iris[1,3]
```

Printing out all of the values for each column 1-5

```{r}
for (i in 1:5) {
  
  # This prints out a statement saying "Here's column i", 
  #but the i gets replaced with the number that it's currently at
  print(paste("Here's column",i))
  
  # This prints out column i
  print(iris[,i])
}
```

Take mean of each column

```{r}
for (i in 1:4) {
  
  # This prints out a statement saying "Here's column i", but the i gets replaced with the number that it's currently at
  print(paste("Here's column",i))
  
  # This prints out column i
  print(mean(iris[,i]))
}
```

Now with across()

```{r}
iris %>% 
  summarize(across(.cols = 1:4, 
                   .fns = mean))
```

### Q2.6 Which do you prefer?

For this example specifically, I think the across function is much more straight forward. The for loop is helpful in many other instance, but for something so simple, the across functions seems to make more sense.

Creating a vector of column names

```{r}
for (i in 1:4) {
  # Fetch the column names of the dataframe, store in a vector "names"
  names <- colnames(iris)
  
  # Print out the "i"th element of the vector to print alongside the output
  print(names[i])
  
  # This prints out column i
  print(mean(iris[,i]))
}
```

### Q2.7 Annotate this code with what you think it’s doing

```{r}
# Store a vector of unique species names from the Species column of Iris
spp_names <- unique(iris$Species)

# Creating a for loop through all values 1 through the length of the spp_names vector
for (i in 1:length(spp_names)) {
  
  filt_data <- iris %>% 
    # filters the iris df where Species is equal to one of each of the species names (since it is a loop it will start with the first then go through all three)
    filter(Species == spp_names[i])
  
  # naming a new object called "plot" to begin creating a plot
  plot <- filt_data %>% 
    # using ggplot to begin mapping our aesthetics of petal length and petal width
    ggplot(aes(x = Petal.Length,
               y = Petal.Width)) +
    # telling ggplot to plot point
    geom_point() +
    # telling ggplot to plot a regression line
    geom_smooth(method = "lm") +
    # giving limits to the x and y axes
    lims(x = c(0,8),
         y = c(0,3)) +
    # Title of the plot will be Species: and then each of the species from the spp_names df 1:3
    ggtitle(paste("Species:", spp_names[i]))
  
  # printing the plot 
  print(plot)
}
```
